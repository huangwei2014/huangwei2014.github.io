<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>test | .</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第1章 熟悉Objective-C1 了解Objective-C语言的起源
OC使用的是『消息结构』而不是『函数调用』，在运行时才会检查对象类型。不论是否多态，总是在运行时才会去查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做『动态绑定』。

OC的重要工作都由『运行期组件』（runtime component）而非编译器来完成。">
<meta property="og:type" content="article">
<meta property="og:title" content="test">
<meta property="og:url" content="http://yoursite.com/2015/04/29/test/index.html">
<meta property="og:site_name" content=".">
<meta property="og:description" content="第1章 熟悉Objective-C1 了解Objective-C语言的起源
OC使用的是『消息结构』而不是『函数调用』，在运行时才会检查对象类型。不论是否多态，总是在运行时才会去查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做『动态绑定』。

OC的重要工作都由『运行期组件』（runtime component）而非编译器来完成。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="test">
<meta name="twitter:description" content="第1章 熟悉Objective-C1 了解Objective-C语言的起源
OC使用的是『消息结构』而不是『函数调用』，在运行时才会检查对象类型。不论是否多态，总是在运行时才会去查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做『动态绑定』。

OC的重要工作都由『运行期组件』（runtime component）而非编译器来完成。">
  
    <link rel="alternative" href="/atom.xml" title="." type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <!-- <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css"> -->
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">.</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-test" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/04/29/test/" class="article-date">
  <time datetime="2015-04-29T05:58:02.000Z" itemprop="datePublished">2015-04-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      test
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="第1章_熟悉Objective-C">第1章 熟悉Objective-C</h2><h4 id="1_了解Objective-C语言的起源">1 了解Objective-C语言的起源</h4><ul>
<li><p>OC使用的是『消息结构』而不是『函数调用』，在运行时才会检查对象类型。不论是否多态，总是在运行时才会去查找所要执行的方法。实际上，编译器甚至不关心接收消息的对象是何种类型。接收消息的对象问题也要在运行时处理，其过程叫做『动态绑定』。</p>
</li>
<li><p>OC的重要工作都由『运行期组件』（runtime component）而非编译器来完成。使用OC的面向对象特性所需的全部数据结构及函数都在运行期组件里面。举例说明，运行期组件中含有全部内存管理方法，运行期组件本质上就是一种与开发者所编代码相链接的『动态库』（dynamic library），其代码能把开发者编写的所有程序粘合起来。  </p>
</li>
<li><p>OC是C的超集，所以必须同时掌握C与OC两门语言，尤其是C的内存模型（memory mode）。当然C++也是要好好学的，尤其是C++对象模型（《深入探索C++对象模型》）。</p>
</li>
<li><p>OC中对象所占内存总是分配在『堆空间』（heap space）中，绝不会分配在栈上。</p>
</li>
<li><p>『栈帧』（stack frame）分配的内存放的是指针。32位上是4字节，64位上是8字节。</p>
</li>
<li><p>分配在堆中的内存必须直接管理，而分配在栈上用于保存变量的内存则会在其栈帧弹出时自动清理。OC将堆内存管理抽象出来了，不需要用<code>malloc</code>及<code>free</code>来分配或释放对象所占内存。OC运行期环境把这部分工作抽象为一套内存管理架构，名叫『引用计数』。</p>
</li>
<li><p>整个系统框架都在使用结构体，如果改用OC对象来做的话，性能会受影响。与创建结构体相比，创建对象还需要额外开销。</p>
</li>
</ul>
<h4 id="2_在类的头文件中尽量少引用其他头文件">2 在类的头文件中尽量少引用其他头文件</h4><ul>
<li><p>将引入头文件的时机尽量延后，只在确有需要时才引入，这样就可以减少类的使用者所需引入的头文件数量。比如『向前声明』<code>@class XXX;</code>，这样可以解决两个类互相引用的问题。</p>
</li>
<li><p>必须在头文件中引入其他头文件时，比如类遵从某个protocol的时候，该protocol必须有完整定义，且不能使用向前声明。向前声明只能告诉编译器有某个protocol，而此时编译器却要知道该protocol中定义的方法。鉴于此，最好是把protocol单独放在一个头文件中，避免引入头文件的全部内容。但是一些protocol，比如『委托协议』就不用单独写一个头文件了。在这种情况下，protocol只有与接受协议委托的类放在一起定义才有意义。此时最好能在实现文件中声明此类实现了该委托协议，并把这段实现代码放在『class-continuation分类』（27）里。这样的话，只要在实现文件中引入包含委托协议的头文件即可，而不需将其放在公共头文件里。这样做不仅可以缩减编译时间，而且还能降低彼此依赖程度。</p>
</li>
</ul>
<h4 id="3_多用字面量语法，少用与之等价的方法">3 多用字面量语法，少用与之等价的方法</h4><ul>
<li><p>使用字面量语法（literal syntax）可以缩减源代码长度，更为易读。例如，<code>NSString *lastName = personData[@&quot;lastName&quot;];</code>，省去了冗赘的语法。</p>
</li>
<li><p>用字面量语法创建数组时要注意，若数组元素对象中有nil，则会抛出异常，这样可以更快地发现这个错误。用字面量语法创建字典时，若有值为nil，也会抛出异常。</p>
</li>
<li><p>字面量语法有个限制，就是除了字符串以外，所创建出来的对象必须属于Foundation框架（NSString、NSNumber、NSArray、NSDictionary）才行。  </p>
</li>
<li><p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的。若想要可变版本的对象，复制一份即可。<code>NSMutableArray *mutable = [@[@1, @2, @3] mutableCopy];</code></p>
</li>
</ul>
<h4 id="4_多用类型常量，少用#define预处理指令">4 多用类型常量，少用#define预处理指令</h4><ul>
<li><p><code>static const NSTimeInterval kAnimationDuration = 0.3</code>，而不是用<code>#define ANIMATION_DURATION 0.3</code>，前一种常量带有类型信息，方便调试。实际编码中<code>#define</code>更常用点。如果一个变量既声明为<code>static</code>，又声明为<code>const</code>，那么编译器根本不会创建符号，而是会像#define预处理指令一样，把所有遇到的变量都替换成常值。</p>
</li>
<li><p><strong>常用的命名法：若常量局限于实现文件中，则在前面加字母k；若常量在类之外可见，则通常以类名为前缀，详情见（19）条。</strong></p>
</li>
<li><p>如果需要一个外界可见的常值变量，可放在『全局符号表』中，以便可以在定义该常量的实现之外使用。如下面代码：该指针是常量，这与需求相符，因为不希望有人改变此指针常量。  </p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// In the header file</span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant;</span><br><span class="line"><span class="comment">// In the implementation file</span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> EOCStringConstant = <span class="string">@"VALUE"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="5_用枚举表示状态、选项、状态码">5 用枚举表示状态、选项、状态码</h4><ul>
<li>在以一系列常量来表示错误状态码或可组合的选项时，极宜使用枚举为其命名。定义选项的时候，应该使用枚举类型，若这些选项可以彼此组合，则更应如此。只要枚举定义的对，各选项之间就可通过『按位或操作符』（bitwise OR operator）来组合。如下面代码：</li>
</ul>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UIViewAutoresizing</span> </span>&#123;  </span><br><span class="line"><span class="constant">    UIViewAutoresizingNone</span> = <span class="number">0</span>,  </span><br><span class="line"><span class="constant">    UIViewAutoresizingFlexibleLeftMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,  </span><br><span class="line"><span class="constant">    UIViewAutoresizingFlexibleWidth</span> = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,  </span><br><span class="line"><span class="constant">    UIViewAutoresizingFlexibleRightMargin</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>枚举不需要互相组合，用<code>NS_ENUM</code>；需要按位或操作来组合的枚举使用<code>NS_OPTIONS</code>。</p>
</li>
<li><p>在处理枚举类型的<code>switch</code>语句中不要实现<code>default</code>分支。这样的话，加入新枚举之后，编译器会提示：<code>switch</code>语句并未处理所有枚举。</p>
</li>
</ul>
<h2 id="第2章对象、消息、运行期">第2章对象、消息、运行期</h2><h4 id="6_理解『属性』这一概念">6 理解『属性』这一概念</h4><ul>
<li><p>使用属性，编译器会自动编写访问这些属性所需的方法，此过程叫做『自动合成』（autosynthesis）。这个过程由编译器在编译期执行，所以编辑器里看不到这些『合成方法』的源代码。编译器还在类中自动添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。</p>
</li>
<li><p>不要在<code>init</code>方法中调用存取方法。</p>
</li>
<li><p>开发iOS程序时一般都会使用<code>nonatomic</code>属性，否则会严重影响性能。但是在开发『Mac OS X』程序时，使用<code>atomic</code>属性通常不会有性能瓶颈。</p>
</li>
<li><p>在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。</p>
</li>
</ul>
<h4 id="7_在对象内部尽量直接访问实例变量">7 在对象内部尽量直接访问实例变量</h4><ul>
<li><p>在对象之外访问实例变量时，总是应该通过属性来做，在对象内部访问实例变量时应采取不同的策略。除了几种特殊情况之外，读取实例变量的时候采用直接访问的形式，而在设置实例变量的时候通过属性来做。</p>
</li>
<li><p>直接访问实例变量和通过属性来访问的区别：</p>
<ol>
<li>由于不经过OC的『方法派发』（11）步骤，所以直接访问实例变量的速度比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。  </li>
<li><strong>直接访问实例变量时，不会调用其『设置方法』，这就绕过了为相关属性所定义的『内存管理语义』。</strong>比如说，如果在ARC下直接访问一个声明为copy的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。</li>
<li>直接访问实例变量，不会触发『键值观察』（Key-Value Observing，<code>KVO</code>）通知。这样做是否会产生问题，还取决于具体的对象行为。</li>
<li>通过属性来访问有助于排查与之相关的错误，因为可以给『获取方法』和『设置方法』中新增『断点』，监控该属性的调用者及其访问时机。</li>
</ol>
</li>
<li><p>合理的折中方案：写入实例变量时，通过其『设置方法』来做，读取实例变量时，则直接访问。</p>
</li>
<li><p>如果使用『惰性初始化』（在get方法中实现），就必须通过属性来读取数据。</p>
</li>
<li><p>在初始化方法和dealloc方法中，总是应该直接通过实例变量来读写数据。</p>
</li>
</ul>
<h4 id="8_理解『对象等同性』这一概念">8 理解『对象等同性』这一概念</h4><ul>
<li><p>NSObject协议中有两个用于判断等同性的方法：<br>  <code>(BOOL)isEqual:(id)object;</code><br>  <code>(NSUInteger)hash;</code></p>
</li>
<li><p>等同性约定：若两对象相等，则<code>hash</code>也相等，但是两个<code>hash</code>相等的对象却未必相等。如果经常需要判断等同性，那么需要自己来创建等同性判定方法，因为无须检测参数类型，所以能大大提升检测速度。  </p>
</li>
<li><p>把某个对象放入collection后，就不应再改变其<code>hash</code>了。因为collection会把各个对象按照其<code>hash</code>分装到不同的『箱子数组』中，如果某对象在放入『箱子』后<code>hash</code>改变了，那么其现在所处的箱子对它来说就是『错误』的。要解决这个问题，需要确保<code>hash</code>不是根据对象的『可变部分』计算出来的，或者保证放入collection后不再改变对象内容了。</p>
</li>
</ul>
<h4 id="9_以『类族模式』隐藏实现细节">9 以『类族模式』隐藏实现细节</h4><ul>
<li><p>类族模式可以把实现细节隐藏在一套简单的公共接口后面。系统框架中经常使用类族，例如<code>NSArray</code>。</p>
</li>
<li><p>若判断某个实例是否位于类族中，应该用<code>isKindOfClass:</code>方法。</p>
</li>
</ul>
<h4 id="10_在既有类中使用关联对象存放自定义数据">10 在既有类中使用关联对象存放自定义数据</h4><ul>
<li><p>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的bug。</p>
</li>
<li><p>在category中声明属性，需用关联对象进行处理，其中的key，可用全局静态变量。</p>
</li>
</ul>
<h4 id="11_理解objc_msgSend的作用">11 理解<code>objc_msgSend</code>的作用</h4><ul>
<li><p>在OC中，如果向某对象传递消息，就会使用动态绑定机制来决定需要调用的方法，这种特性使得OC成为一门真正的动态语言。</p>
</li>
<li><p>编译器看到消息后，将其转换为一条标准的C语言函数调用，就是<code>objc_msgSend</code>，『原型』（prototype）如下：<br><code>void objc_msgSend(id self, SEL cmd, ...)</code></p>
</li>
<li><p><code>objc_msgSend</code>函数会依据接收者与选择子的类型来调用适当的方法，在接收者所属的类中搜寻其『方法列表』，如果找不到，就沿着继承体系继续向上查找。如果还是找不到，就执行『消息转发』（message forwarding）（12）。</p>
</li>
</ul>
<h4 id="12_理解消息转发机制">12 理解消息转发机制</h4><ul>
<li><p>若对象无法响应某个选择子，则进入消息转发流程。通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。对象可以把其无法解读的某些选择子转交给其他对象来处理。经过上述两步之后，如果还是无法处理选择子，那就启动完整的消息转发机制。</p>
</li>
<li><p>对象在收到无法解读的消息后，首先将调用其所属类的类方法：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)selector  </span><br><span class="line">&#123;  </span><br><span class="line">	<span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(selector);  </span><br><span class="line">	<span class="comment">// class_addMethod(self, selector, (IMP)methodName, "v@:@");  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="13_用『方法调配技术』调试『黑盒方法』">13 用『方法调配技术』调试『黑盒方法』</h4><ul>
<li><p>在运行期，可以向类中新增或替换选择子所对应的方法实现。</p>
</li>
<li><p>一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。 </p>
</li>
</ul>
<h4 id="14_理解『类对象的用意』">14 理解『类对象的用意』</h4><ul>
<li><p>『在运行期检视对象类型』这一操作叫做『类型信息查询（<strong>内省</strong>）』</p>
</li>
<li><p><code>isMemberOfClass</code>：能够判断出对象是否为某个特定类的实例。</p>
</li>
<li><p><code>isKindOfClass</code>：能够判断出对象是否为某类或其派生类的实例。</p>
</li>
<li><p>尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</p>
</li>
</ul>
<h2 id="第3章接口与API设计">第3章接口与API设计</h2><h4 id="15_用前缀避免命名空间冲突">15 用前缀避免命名空间冲突</h4><ul>
<li>Apple宣称其保留使用所有『两字母前缀』的权利，所以自己选用的前缀应该是三个字母的。</li>
</ul>
<h4 id="16_提供『全能初始化方法』">16 提供『全能初始化方法』</h4><ul>
<li><p>『全能初始化方法』：为对象提供必要信息以便其能完成工作的初始化方法。换句话说，其他的初始化方法最终都需要调用这个方法，只有在全能初始化方法中，才会存储内部数据。这样的话，当底层数据存储机制改变时，只需修改此方法的代码就好，无须改动其他初始化方法。</p>
</li>
<li><p>每个子类的全能初始化方法都应该调用其超类的对应方法，并逐层向上。在类中提供一个全能初始化发方法，并在文档中指明，其他初始化方法均应调用此方法。  </p>
</li>
</ul>
<h4 id="17_实现description方法">17 实现description方法</h4><ul>
<li><p><code>NSLog</code>中的<code>%@</code>会调用<code>description</code>方法，所以需要打印的信息写在<code>description</code>中就可以了。  </p>
</li>
<li><p>断点，在命令行里输入<code>po XXX</code>打印对象信息。  </p>
</li>
</ul>
<h4 id="18_尽量使用不可变对象">18 尽量使用不可变对象</h4><ul>
<li><p>如果把可变对象放入collection之后又修改其内容，那么很容易就会破坏<code>set</code>的内部数据结构，使其失去固有的语义。因此，尽量减少对象中的可变内容。  </p>
</li>
<li><p>不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。  </p>
</li>
</ul>
<h4 id="19_使用清晰而协调的命名方式">19 使用清晰而协调的命名方式</h4><ul>
<li><p>如果方法的返回值是新创建的，那么方法名的首个词应是返回值的类型，除非前面还有修饰语，例如localizedString。  </p>
</li>
<li><p>方法名里不要使用缩略后的类型名称，例如str，应使用string。  </p>
</li>
</ul>
<h4 id="20_为私有方法名加前缀">20 为私有方法名加前缀</h4><ul>
<li><p>苹果公司在文档中说，开发者不应该单用一个下划线做前缀来命名『方法』。  </p>
</li>
<li><p>给私有方法的名称加上前缀，如<code>p_XXX</code>，这样可以容易将其同公共方法区分开。  </p>
</li>
</ul>
<h4 id="21_理解Objective-C错误模型">21 理解Objective-C错误模型</h4><ul>
<li><code>NSError</code>的常见用法：  </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)doSomething:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line">	<span class="built_in">NSError</span> *error = <span class="literal">nil</span>;  </span><br><span class="line">	<span class="built_in">BOOL</span> ret = [object doSomething:&amp;error]();  </span><br><span class="line">	<span class="keyword">if</span> (error) &#123;  </span><br><span class="line">		<span class="comment">// There was an error  </span></span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>NSError</code>对象里封装了三条信息：  </p>
<ol>
<li><code>Error domain</code>：错误范围，类型是字符串，全局变量。  </li>
<li><code>Error code</code>：错误码，类型是整数，枚举。  </li>
<li><code>User info</code>：用户信息，类型是字典。  </li>
</ol>
</li>
<li><p>示例代码：</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// EOCErrors.h  </span></span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">NSString</span> *<span class="keyword">const</span> EOCErrorDomain;  </span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, EOCError) &#123;  </span><br><span class="line">    EOCErrorUnknown = -<span class="number">1</span>,  </span><br><span class="line">    EOCErrorInternalInconsistency = <span class="number">100</span>,  </span><br><span class="line">    EOCErrorGeneralFault = <span class="number">105</span>,  </span><br><span class="line">    EOCErrorBadInput = <span class="number">500</span>,  </span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">// EOCErrors.m  </span></span><br><span class="line"><span class="built_in">NSString</span> *<span class="keyword">const</span> EOCErrorDomain = <span class="string">@"EOCErrorDomain"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="22_理解NSCopying协议">22 理解NSCopying协议</h4><ul>
<li><code>NSCopying</code>协议需要实现的方法是：<code>copyWithZone:</code>。  </li>
</ul>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (id)<span class="symbol">copyWithZone:</span>(<span class="constant">NSZone</span> *)zone  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="constant">EOCPerson</span> *person = [[[<span class="keyword">self</span> <span class="class"><span class="keyword">class</span>] <span class="title">allocWithZone</span>:<span class="title">zone</span>] <span class="title">init</span>];</span>  </span><br><span class="line">    <span class="keyword">return</span> person;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>遵从了NSCopying协议的对象大多执行浅copy，如需深copy，那么在文档中说明。</li>
</ul>
<h2 id="第4章协议与分类">第4章协议与分类</h2><h4 id="23_通过委托与数据源协议进行对象间通信">23 通过委托与数据源协议进行对象间通信</h4><ul>
<li><p>委托对象必须定义成<code>weak</code>、<code>unsafe_unretained</code>、<code>assign</code>，因为两者之间必须为『非拥有关系』，通常情况下，扮演delegate的那个对象也要持有本对象。  </p>
</li>
<li><p>如果要在委托对象上调用可选方法，那么必须提前使用类型信息查询方法判断这个委托对象能否响应相关selector，代码如下:  </p>
</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> ([_delegate <span class="attribute">respondsToSelector</span>:<span class="variable">@selector</span>(<span class="comment">/*方法名*/</span>)]  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="attr_selector">[_delegate 方法名]</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在调用delegate对象中的方法时，总是应该把发给委托的实例也一并传入方法中，这样，delegate对象在实现相关方法时，就能根据传入的实例分别执行不同的代码了。  </p>
</li>
<li><p>在获取数据时如果遇到了『重定向』，可以询问其委托对象是否应该发生重定向。</p>
</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">-</span> (<span class="tag">BOOL</span>) <span class="rule"><span class="attribute">networkFetcher</span>:<span class="value">(EOCNetworkFetcher *)fetcher shouldFollowRedirectToURL:(NSURL *)url</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>很容易用代码查出某个委托对象是否能响应特定的选择子，可是如果频繁执行此操作的话，那么除了第一次检测的结果有用之外，后续的检测可能都是多余的。所以需要将方法响应能力缓存起来，最佳途径是使用『位段』数据类型。  </li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@interface</span> EOCNetworkFetcher()  </span><br><span class="line">&#123;  </span><br><span class="line">    struct &#123;  </span><br><span class="line">    	unsigned <span class="typename">int</span> <span class="string">didReceiveData :</span> <span class="number">1</span>;  </span><br><span class="line">		unsigned <span class="typename">int</span> <span class="string">didFailWithError :</span> <span class="number">1</span>;  </span><br><span class="line">		unsigned <span class="typename">int</span> <span class="string">didUpdateProgressTo :</span> <span class="number">1</span>;  </span><br><span class="line">    &#125; _delegateFlags;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="annotation">@end</span>  </span><br><span class="line"></span><br><span class="line">(<span class="typename">void</span>)<span class="string">setDelegate:</span>(id&lt;EOCNetworkFetcher&gt; delegate)  </span><br><span class="line">&#123;  </span><br><span class="line">    _delegate = delegate;  </span><br><span class="line">    _delegateFlags.didReceiveData = [delegate <span class="string">respondsToSelector:</span><span class="annotation">@selector</span>(<span class="string">networkFetcher:</span><span class="string">didReceiveData:</span>)];  </span><br><span class="line">    _delegateFlags.didFailWithError = <span class="comment">/*基本同上*/</span>;  </span><br><span class="line">    _delegateFlags.didUpdateProgressTo = <span class="comment">/*基本同上*/</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_delegateFlags.didUpdateProgressTo) &#123;  </span><br><span class="line">    [_delegate <span class="string">networkFetcher:</span>self <span class="string">didUpdateProgressTo:</span>currentProgress];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当某对象需要从另外一个对象中获取数据时，可以使用委托模式，又称『数据源协议』（data source protocol）。  </li>
</ul>
<h4 id="24_将类的实现代码分散到便于管理的数个分类之中">24 将类的实现代码分散到便于管理的数个分类之中</h4><ul>
<li><p>类的基本要素（属性和初始化方法等）都声明在『主方法』（main implementation）里。执行不同类型的操作所用的另外几套方法则归入各个分类中。也可以单独放到不同的文件中去。将类代码打散到分类中可以便于调试。对于某个分类中的所有方法来说，分类名称都会出现在其符号中。  </p>
</li>
<li><p>视为私有方法可以创建名为Private的分类，把这种方法全部放在里面。  </p>
</li>
</ul>
<h4 id="25_总是为第三方类的分类名称加前缀">25 总是为第三方类的分类名称加前缀</h4><ul>
<li>加前缀是为了防止方法覆盖，出现奇怪的bug。  </li>
</ul>
<h4 id="26_勿在分类中声明属性">26 勿在分类中声明属性</h4><ul>
<li><p>如果要在分类中声明属性，需借助关联对象解决在分类中不能合成实例变量的问题。但是这种方法要把相似的代码写很多遍，而且在内存管理问题上容易出错。  </p>
</li>
<li><p>正确做法是把所有属性都定义在主接口中。有时候只读属性还是可以在分类中使用的，但是需要实现读取方法。  </p>
</li>
</ul>
<h4 id="27_使用『class-continuation分类』隐藏实现细节">27 使用『class-continuation分类』隐藏实现细节</h4><ul>
<li><p>编写Objective-C++代码时『class-continuation分类』也很有用，应该把头文件中的C++代码放入到实现中去。某些系统库用到了这种模式，比如网页浏览器框架<code>WebKit</code>，其大部分代码都以C++编写，然而对外展示出来的却是一套整洁的OC接口。<code>CoreAnimation</code>也用到了这种模式。</p>
</li>
<li><p>如果某<code>property</code>在接口中声明为『只读』，而类的内部又要用设置方法修改此属性，那么就在『class-continuation分类』中将其扩展为『可读写』，重新声明即可。  </p>
</li>
<li><p>把私有方法的原型声明在『class-continuation分类』里面。若想使类所遵循的协议不为人所知，则可在『class-continuation分类』中声明。  </p>
</li>
</ul>
<h4 id="28_通过协议提供匿名对象">28 通过协议提供匿名对象</h4><ul>
<li><p>用协议把自己所写的API之中的实现细节隐藏起来，将返回的对象设计为遵从此协议的纯id类型。因为有时候它们不能以某个公共基类来统一表示。  </p>
</li>
<li><p>字典中，键的标准内存管理语义是『copy』，值的语义是『retain』。因此，在NSMutableDictionary中设置键值用的方法如下，字典对象只要能确定它可以给此实例发送copy消息就可以了。  </p>
</li>
<li><p>处理数据库连接（database connection）的程序库也用这个思路，以匿名对象来表示从另一个库中所返回的对象。  </p>
</li>
<li><p>如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可使用匿名对象来表示。  </p>
</li>
</ul>
<h2 id="第5章内存管理">第5章内存管理</h2><h4 id="29_理解引用计数">29 理解引用计数</h4><ul>
<li><p>NSObject协议声明了三个方法用于操作计数器，以递增或递减其值：  </p>
<ol>
<li>retain：递增保留计数  </li>
<li>release：递减保留计数  </li>
<li>autorelease：待稍后清理autorelease pool时，再递减保留计数  </li>
</ol>
</li>
<li><p>绝不应该说保留计数一定是某个值，只能说你所执行的操作是递增了该计数还是递减了该计数。  </p>
</li>
<li><p>为避免在不经意间使用了无效对象，一般调用完<code>release</code>之后都会清空指针，赋值<code>nil</code>即可。下面是安全删除指针的宏定义：  </p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> RELEASE_SAFELY(__POINTER) <span class="keyword">if</span> (__POINTER) &#123;[__POINTER release]; __POINTER = nil;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>属性存取方法中的内存管理  </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// retain  </span></span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="keyword">id</span>)foo &#123;  </span><br><span class="line">	<span class="keyword">if</span> (_foo != foo) &#123;  </span><br><span class="line">		[foo retain];  </span><br><span class="line">		[_foo release];  </span><br><span class="line">		_foo = foo;  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// assgin  </span></span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="keyword">id</span>)foo &#123;</span><br><span class="line">	_foo = foo;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy  </span></span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="keyword">id</span>)foo &#123;  </span><br><span class="line">	<span class="keyword">if</span> (_foo != foo) &#123;  </span><br><span class="line">		[_foo release];  </span><br><span class="line">		_foo = [foo <span class="keyword">copy</span>];  </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用autorelease可以保证对象在跨越『方法调用边界』后一定存活，用在返回对象的方法中。</li>
</ul>
<h4 id="30_以ARC简化引用计数">30 以ARC简化引用计数</h4><ul>
<li><p>内存泄漏：没有正确释放已经不再使用的内存。  </p>
</li>
<li><p>使用ARC时要记住，引用计数实际上还是要执行的，只不过保留与释放操作现在是由ARC自动添加的。  </p>
</li>
<li><p>ARC在调用这些方法时，并不通过普通的OC消息派发机制，而是直接调用其底层C语言版本。这样做性能更好，因为retain和release操作需要频繁执行。例如，ARC会调用与retain等价的底层函数<code>objc_retain</code>。  </p>
</li>
<li><p>方法名以下列词语开头，则其返回的对象归调用者所有：<code>alloc</code>、<code>new</code>、<code>copy</code>、<code>mutableCopy</code>，否则不归调用者所有。归调用者所有的意思是：调用上述四种方法的那段代码要负责释放方法所返回的对象。以<code>new</code>、<code>copy</code>、<code>mutableCopy</code>、<code>alloc</code>开头的方法，都应当由调用者来<code>release</code>，而其他方法，都返回一个<code>aurelease</code>对象。  </p>
</li>
<li><p>ARC可以执行一些手工操作很难甚至无法完成的优化，例如，在编译器，ARC会把能够互相抵消的retain、release、autorelease操作约简。  </p>
</li>
<li><p>ARC默认情况下，每个变量都是指向对象的强引用，非ARC则不是。有了ARC，就无需担心内存管理问题了，可以省去类中的许多『样板代码』。  </p>
</li>
<li><p>在应用程序中，可用下列修饰符来改变局部变量与实例变量的语义：  </p>
<ol>
<li><code>__strong</code>：默认语义，保留此值。  </li>
<li><code>__unsafe_unretained</code>：不保留此值。  </li>
<li><code>__weak</code>：不保留此值，但是变量可以安全使用。  </li>
<li><code>__autorelease</code>：此值在方法返回时自动释放。  </li>
</ol>
</li>
<li><p>ARC只负责管理OC对象的内存，CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain或CFRelease。  </p>
</li>
</ul>
<h4 id="31_在dealloc方法中只释放引用并解除监听">31 在dealloc方法中只释放引用并解除监听</h4><ul>
<li><p>在dealloc中释放监听，<code>NSNotificationCenter</code>或<code>KVO</code>，不要做其他事情。示例代码：<code>[[NSNotificationCenter defaultCenter] removeObserver:self];</code>  </p>
</li>
<li><p>应该在dealloc中释放引用，但是开销较大或系统内稀缺的资源是特例，如文件描述符、套接字、大块内存等。  </p>
</li>
<li><p>执行异步任务的方法不应在dealloc里调用；只有在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。  </p>
</li>
</ul>
<h4 id="32_编写『异常安全代码』时留意内存管理问题">32 编写『异常安全代码』时留意内存管理问题</h4><ul>
<li><p>在OC代码中，只有当应用程序必须因异常状况而终止时才应抛出异常，这时应用程序即将终止，那么是否还会发生内存泄漏就已经无关紧要了。  </p>
</li>
<li><p>在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标识后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。可以用<code>NSError</code>式错误信息传递来取代异常。  </p>
</li>
</ul>
<h4 id="33_以弱引用避免保留环">33 以弱引用避免保留环</h4><ul>
<li>使用<code>weak</code>而非<code>unsafe_unretained</code>引用可以令代码更安全，应用程序也许会显示错误的数据，但不会直接崩溃，因为weak可以自动置为nil。  </li>
</ul>
<h4 id="34_以『自动释放池块』降低内存峰值">34 以『自动释放池块』降低内存峰值</h4><ul>
<li><p>内存峰值是指应用程序在某个特定时段内的最大内存用量。用在for循环语句中，可减小内存峰值。  </p>
</li>
<li><p><code>@autoreleasepool{}</code>方法比老式的<code>NSAutorelease</code>方法更轻便。  </p>
</li>
</ul>
<h4 id="35_用『僵尸对象』调试内存管理问题">35 用『僵尸对象』调试内存管理问题</h4><ul>
<li><p>向已回收的对象发送消息是不安全的，这么做有时可以，有时不行。具体可行与否，完全取决于对象所占内存有没有为其他内容所覆写。而这块内存有没有移作他用，又无法确定，因此，应用程序只是偶尔崩溃。  </p>
</li>
<li><p>Cocoa提供了『僵尸对象』（Zombie Object），启动这个调试功能之后，运行期系统会把所有已经回收的实例转化成特殊的『僵尸对象』，而不会真正回收它们。这种对象所在的核心内存无法重用，因此不可能遭到覆写。僵尸对象收到消息后，会抛出异常，其中准确说明了发送出来的消息，并描述了回收之前的那个对象。僵尸对象是调试内存管理问题的最佳方式。  </p>
</li>
<li><p>Xcode打开『僵尸对象』：Product-&gt;Scheme-&gt;Edit Scheme-&gt;Run-&gt;Diagnostics。  </p>
</li>
<li><p>打开僵尸对象后，内存无法释放，但这只是一个调试手段，制作正式发行的应用程序时不会把这项功能打开。  </p>
</li>
<li><p>跟Xcode自带的<code>instruments</code>搭配，调试效果更好。  </p>
</li>
<li><p>系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。  </p>
</li>
</ul>
<h4 id="36_不要使用retainCount">36 不要使用retainCount</h4><ul>
<li><p>系统会尽可能把NSString实现成单例对象，因此其保留计数都很大。  </p>
</li>
<li><p>任何给定时间点上的『绝对保留计数』都无法反映对象生命期的全貌。  </p>
</li>
</ul>
<h2 id="第6章块与大中枢派发">第6章块与大中枢派发</h2><h4 id="37_理解『块』这一概念">37 理解『块』这一概念</h4><ul>
<li><p>在块的声明范围里，所有变量都可以被其捕获。block捕获的变量在块中不可变，但是加上<code>__block</code>即可变。如果块所捕获的变量是对象类型，那么就会自动保留它。块也是对象，有引用计数，回收时会释放块所捕获的变量，以便平衡捕获时所执行的保留操作。  </p>
</li>
<li><p>如果将块定义在Objective-C类的实例方法中，除了可以访问类的所有实例变量外，还可以使用<code>self</code>变量。块总能修改实例变量，所以在声明时无须加<code>__block</code>。  </p>
</li>
<li><p>self也是个对象，因而块在捕获它时也会将其保留。如果self所指代的那个对象同时也保留了块，就会导致『保留环』。  </p>
</li>
<li><p>定义块的时候，所占的内存区域都是分配在栈中的。块只在定义它的那个范围内有效。为解决这个问题，可给块对象发送<code>copy</code>消息，这样就可以把块从栈复制到堆了。copy后的块，就可以在定义它的那个范围之外使用。一旦复制到堆上，块就成了带引用计数的对象了。后续的copy操作都不会真的执行复制，只是递增块对象的引用计数。如果不再使用这个块，那就应将其释放。  </p>
</li>
<li><p>全局块不会捕捉任何状态，运行时也无须有状态来参与。如果运行块所需的全部信息都能在编译期确定，就可以做成全局块。  </p>
</li>
</ul>
<h4 id="38_为常用的块类型创建typedef">38 为常用的块类型创建typedef</h4><ul>
<li><p>在使用块类型的类中定义这些typedef，而且应该把这个类的名字加到由typedef所定义的新类型名前面。  </p>
</li>
<li><p>给块起别名，而且可以给同一个块签名定义多个类型别名。  </p>
</li>
<li><p>如果有好几个类都要执行相似但各有区别的异步任务，而这几个类又不能放入同一个继承体系，那么每个类应该有自己的completion handler类型。  </p>
</li>
</ul>
<h4 id="39_用handler块降低代码分散程度">39 用handler块降低代码分散程度</h4><ul>
<li><p>『异步执行任务『设计技巧之一是采用委托模式，但是有个缺点是：如果类要分别使用多个获取器下载不同数据，那么就得在delegate回调方法里根据传入的获取器参数来切换，这样会使代码量激增。这时可以采用block来处理。  </p>
</li>
<li><p>总体来说，建议使用同一个块来处理成功和失败情况，苹果公司也是这样设计其API的。多个块也是可以的。  </p>
</li>
<li><p>创建对象时，可以使用内联的handler块将相关业务逻辑一并声明。  </p>
</li>
</ul>
<h4 id="40_用块引用其所属对象时不要出现保留环">40 用块引用其所属对象时不要出现保留环</h4><ul>
<li><p>如果拥有块的实例变量，那么用完后应置为nil，避免『保留环』。  </p>
</li>
<li><p>如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。  </p>
</li>
</ul>
<h4 id="41_多用派发队列，少用同步锁">41 多用派发队列，少用同步锁</h4><ul>
<li>派发队列可用来表述同步语义，比使用<code>@synchronized</code>块或<code>NSLock</code>对象更简单。  </li>
</ul>
<h4 id="42_多用GCD，少用performSelector系列方法">42 多用GCD，少用performSelector系列方法</h4><ul>
<li>延后执行任务  </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using dispatch_after  </span></span><br><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">5.0</span> * <span class="built_in">NSEC_PER_SEC</span>));  </span><br><span class="line">dispatch_after(time, dispatch_get_main_queue(), ^(<span class="keyword">void</span>) &#123;  </span><br><span class="line">	[<span class="keyword">self</span> doSomething];  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>performSelector方法在内存管理方面容易有疏失，而且处理的选择子太过局限了，比GCD差很多。  </li>
</ul>
<h4 id="43_掌握GCD及操作队列的使用时机">43 掌握GCD及操作队列的使用时机</h4><ul>
<li><p>在解决多线程和任务管理问题时，可采用GCD和NSOperationQueue，后者更好点。  </p>
</li>
<li><p>使用NSOperation和NSOperationQueue的好处：可以取消某个操作，GCD则不行；通过KVO监控NSOperation对象的属性，如任务是否取消等；指定操作的优先级；可以重复使用NSOperation对象。  </p>
</li>
<li><p>操作队列提供了一套高层的Objective-C API，能实现纯GCD所具备的绝大部分功能，还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码。  </p>
</li>
</ul>
<h4 id="44_通过Dispatch_Group机制，根据系统资源状况来执行任务">44 通过Dispatch Group机制，根据系统资源状况来执行任务</h4><ul>
<li><p>一系列任务可归入一个dispatch group中，开发者可以在这组任务执行完毕时获得通知。  </p>
</li>
<li><p>通过dispatch group，可以在并发式派发队列里同时执行多项任务，此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。  </p>
</li>
</ul>
<h4 id="45_使用dispatch_once来执行只需运行一次的线程安全代码">45 使用<code>dispatch_once</code>来执行只需运行一次的线程安全代码</h4><ul>
<li>单例模式代码如下，其中标记应该声明在static或global作用域中，保证执行一次。  </li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)sharedInstance &#123;  </span><br><span class="line">	<span class="keyword">static</span> XXXClass *sharedInstance = <span class="literal">nil</span>;  </span><br><span class="line">	<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;  </span><br><span class="line">	<span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;  </span><br><span class="line">		sharedInstance = [[<span class="keyword">self</span> alloc] init];  </span><br><span class="line">	&#125;);  </span><br><span class="line">	<span class="keyword">return</span> sharedInstance;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="46_不要使用dispatch_get_current_queue">46 不要使用<code>dispatch_get_current_queue</code></h4><ul>
<li><code>dispatch_get_current_queue</code>函数的行为常常与开发者所预期的不同，此函数已经废弃，只应做调试之用。  </li>
</ul>
<h2 id="第7章系统框架">第7章系统框架</h2><h4 id="47_熟悉系统框架">47 熟悉系统框架</h4><ul>
<li><p>Foundation（OC）和CoreFoundation（C）之间用『无缝桥接』（tollfree bridging）进行转换。  </p>
</li>
<li><p>用C实现API的好处是，可以绕过OC的运行期系统，从而提升执行速度。由于ARC只负责OC对象，所以使用这些API时尤其需要注意内存管理问题。  </p>
</li>
<li><p>用纯C写成的框架与用OC写成的一样重要，若想成为优秀的OC开发者，应该掌握C语言的核心概念。  </p>
</li>
</ul>
<h4 id="48_多用块枚举，少用for循环">48 多用块枚举，少用for循环</h4><ul>
<li><p>遍历的4种方法：for、NSEnumerator、快速遍历（for in）和块（推荐），均可反向遍历。  </p>
</li>
<li><p>块：enumerateObjectsUsingBlock:，如果知道某collection里的对象是什么类型，那就应该<strong>指明类型</strong>。  </p>
</li>
<li><p><code>- (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block</code>  </p>
</li>
</ul>
<h4 id="49_对自定义其内存管理语义的collection使用无缝桥接">49 对自定义其内存管理语义的collection使用无缝桥接</h4><ul>
<li><p>通过无缝桥接技术<code>__bridge</code>，可以在Foundation框架中的OC对象与CoreFoundation框架中的C语言数据结构之间来回转换。  </p>
</li>
<li><p>在CoreFoundation层面创建collection时，可以指定许多回调函数，这些函数表示此collection应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内存管理语义的Objective-C collection。  </p>
</li>
<li><p>字典中『键』内存管理语义是『拷贝』，值的语义是『保留』，只能使用无缝桥接技术改变其语义。  </p>
</li>
</ul>
<h4 id="50_构建缓存时选用NSCache而非NSDictionary">50 构建缓存时选用NSCache而非NSDictionary</h4><ul>
<li><p>NSCache可以在系统资源将要耗尽时能够自动删减缓存，而且是线程安全，与字典不同的是并不会拷贝键。  </p>
</li>
<li><p>只有『重新计算起来很费事的』数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</p>
</li>
</ul>
<h4 id="51_精简initialize与load的实现代码">51 精简initialize与load的实现代码</h4><ul>
<li>在加载阶段，如果类实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。</li>
</ul>
<h4 id="52_别忘了NSTimer会保留其目标对象">52 别忘了NSTimer会保留其目标对象</h4><ul>
<li>NSTimer对象会保留其target，直到计时器本身失效为止，调用invalidate方法可令计时器失效，一次性的计时器在触发完任务之后也会失效。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/04/29/test/" data-id="ci92c3vfc0001942m3eg5g1sm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2015/04/28/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/04/29/test/">test</a>
          </li>
        
          <li>
            <a href="/2015/04/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 .<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="http://cdn.bootcss.com/jquery/2.1.1/jquery.min.js" > </script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>